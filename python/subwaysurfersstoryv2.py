# -*- coding: utf-8 -*-
"""SubwaySurfersStoryV2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12OiJ1N0ouBfSD1AfxK73ku5bI3hdX4gd
"""

from google.colab import drive
drive.mount('/content/drive')

# Install required packages for YouTube upload
!pip install --upgrade google-api-python-client google-auth google-auth-oauthlib google-auth-httplib2

!ls /content/drive/MyDrive/n8n/videos/

!apt-get update

!apt-get install ffmpeg

!ffmpeg -version

config_path = '/content/drive/MyDrive/n8n/videos/config.txt'

with open(config_path, 'r') as f:
    lines = f.read().strip().split('\n')

folder_name = lines[0]
background_video = lines[1]

# Set up all the paths
base_path = '/content/drive/MyDrive/n8n/videos'
assets_path = '/content/drive/MyDrive/n8n/assets'
folder_path = f'{base_path}/{folder_name}'

# File paths
audio_file = f'{folder_path}/audio.mp3'
words_file = f'{folder_path}/WordTimestamps.txt'
background_video_path = f'{assets_path}/{background_video}'

# Output paths (keeping your existing structure)
output_base = '/content/drive/MyDrive/n8n/workflow'
gameplay_footage = f'{folder_path}/gameplay_footage.mp4'
gameplay_audio = f'{folder_path}/gameplay_audio.mp4'

print(f"Folder: {folder_name}")
print(f"Background video: {background_video}")
print(f"Audio file: {audio_file}")
print(f"Words file: {words_file}")
print(f"Background video path: {background_video_path}")

!ffmpeg -i "{background_video_path}" -i "{audio_file}" -c:v copy -c:a aac -shortest "{gameplay_audio}"

import json

# Read the word timestamps from the dynamic file
with open(words_file, 'r', encoding='utf-8') as f:
    raw_n8n_output = f.read()

print("Word timestamps loaded successfully!")
print(f"First 200 characters: {raw_n8n_output[:200]}...")

# Optional: remove trailing commas or JavaScript-style comments if needed
import re

# Strip JS-style comments
clean_json = re.sub(r'//.*', '', raw_n8n_output)

# Load as Python object
words = json.loads(clean_json)

# Check the result
print(words[0])

from datetime import timedelta
import re
import json  # Needed if you're parsing from raw JSON

def format_timestamp(seconds: float) -> str:
    t = timedelta(seconds=seconds)
    total_seconds = int(t.total_seconds())
    ms = int((seconds - total_seconds) * 100)
    h = total_seconds // 3600
    m = (total_seconds % 3600) // 60
    s = total_seconds % 60
    return f"{h}:{m:02d}:{s:02d}.{ms:02d}"

def clean_word(word: str) -> str:
    return re.sub(r'[^\w\s]', '', word).upper()

def generate_karaoke_ass_subtitles(words, group_size=(2, 4)):
    header = """[Script Info]
Title: Short Form Video
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, ShadowColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Karaoke,Comic Sans MS,18,&H00FFFFFF,&H000000FF,&H00000000,&&HFFFFFD01,0,0,0,0,100,100,0,0,1,1,1,5,10,10,20,1
Style: Default,Comic Sans MS,18,&H00AAAAAA,&H000000FF,&H00000000,&&HFFFFFD01,1,0,0,0,100,100,0,0,1,3,1,5,10,10,20,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text"""

    body = ""
    i = 0
    while i < len(words):
        group_len = min(group_size[1], len(words) - i)
        if group_len < group_size[0] and i + group_len == len(words):
            group_len = len(words) - i
        group = words[i:i + group_len]

        # Start and end times for the whole dialogue line
        start_time = format_timestamp(group[0]["start"])
        end_time = format_timestamp(group[-1]["end"])

        # Build karaoke text: {\k<duration>}WORD
        karaoke_line = ""
        for word in group:
            duration = int((word["end"] - word["start"]) * 100)
            cleaned = clean_word(word["word"])
            karaoke_line += f"{{\\k{duration}}}{cleaned} "

        karaoke_line = karaoke_line.strip()

        # Append to body with the "Karaoke" style
        body += f"\nDialogue: 0,{start_time},{end_time},Karaoke,,0,0,0,,{karaoke_line}"

        i += group_len

    return header + body

ass_text = generate_karaoke_ass_subtitles(words)
print(ass_text)

ass_text = generate_karaoke_ass_subtitles(words)

temp_path = f'{folder_path}/workflowSubtitles.ass'

with open(temp_path, 'w', encoding='utf-8') as f:
    f.write(ass_text)

print("✅ Karaoke-style .ass file generated and saved to Google Drive.")
print(f"Saved to: {temp_path}")

!ffmpeg -i "{gameplay_audio}" \
-vf "ass='{temp_path}'" \
-c:a copy "{folder_path}/final.mp4"

!pip install pillow

import random

# Lists of words for username generation
adjectives = [
    "Cool", "Epic", "Wild", "Fast", "Smart", "Brave", "Quick", "Silent",
    "Dark", "Bright", "Happy", "Lucky", "Strong", "Wise", "Bold", "Swift",
    "Tiny", "Giant", "Flying", "Dancing", "Singing", "Running", "Jumping",
    "Sleepy", "Angry", "Crazy", "Lazy", "Busy", "Funny", "Silly", "Weird",
    "Super", "Ultra", "Mega", "Mini", "Great", "Amazing", "Awesome", "Cool",
    "Hot", "Cold", "Warm", "Soft", "Hard", "Sharp", "Smooth", "Rough"
]

nouns = [
    "Tiger", "Eagle", "Wolf", "Bear", "Lion", "Fox", "Owl", "Hawk", "Snake",
    "Dragon", "Phoenix", "Raven", "Falcon", "Shark", "Whale", "Dolphin",
    "Panda", "Koala", "Monkey", "Elephant", "Giraffe", "Zebra", "Rhino",
    "Thunder", "Lightning", "Storm", "Fire", "Ice", "Wind", "Mountain", "Ocean",
    "River", "Forest", "Desert", "Valley", "Peak", "Star", "Moon", "Sun",
    "Knight", "Warrior", "Hunter", "Scout", "Guardian", "Champion", "Hero",
    "Wizard", "Ninja", "Samurai", "Viking", "Pirate", "Robot", "Cyborg",
    "Pizza", "Cookie", "Cake", "Burger", "Taco", "Sandwich", "Coffee", "Tea",
    "Gamer", "Player", "Master", "Legend", "Pro", "Noob", "King", "Queen"
]

def generate_username():
    """Generate a random Reddit-style username"""
    # Pick two random words
    word1 = random.choice(adjectives)
    word2 = random.choice(nouns)

    # Generate 3-4 random numbers
    num_digits = random.choice([3, 4])
    numbers = ''.join([str(random.randint(0, 9)) for _ in range(num_digits)])

    # Combine them
    username = f"{word1}{word2}{numbers}"

    return username

# Generate a few examples
print("Generated Reddit usernames:")
print("-" * 30)
for i in range(10):
    username = generate_username()
    print(f"{i+1:2d}. {username}")

print("\n" + "="*40)
print("Pick one you like and update the reddit generator!")

# Generate one for immediate use
selected_username = generate_username()
print(f"\nSuggested username: {selected_username}")
print(f"\nTo use this username, update the reddit generator with:")
print(f'username = "{selected_username}"')

post_title = lines[2]
subreddit = "r/AmItheAsshole"

timestamp = "5 yr. ago"
flair_text = "Not the A-hole"
print(f"Post title: {post_title}")
print(f"Subreddit: {subreddit}")
print(f"Timestamp: {timestamp}")
print(f"Flair text: {flair_text}")
print(username)

from PIL import Image, ImageDraw, ImageFont
import os


# === Settings ===
width, height = 1080, 350
bg_color = (24, 26, 27)  # Dark Reddit background
text_color = (255, 255, 255)  # White text
flair_bg_color = (107, 150, 255)  # Blue flair background
flair_text_color = (255, 255, 255)  # White flair text

# === Create Image ===
img = Image.new("RGB", (width, height), color=bg_color)
draw = ImageDraw.Draw(img)

# Check what fonts are available
print("Checking available fonts...")
font_dirs = ["/usr/share/fonts/", "/System/Library/Fonts/"]
for font_dir in font_dirs:
    if os.path.exists(font_dir):
        print(f"Font directory {font_dir} exists")
    else:
        print(f"Font directory {font_dir} not found")

# === Font Setup ===
def get_font(size, bold=False):
    # Try multiple font paths that are commonly available in Colab
    font_paths = [
        # DejaVu fonts (most common)
        "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf" if bold else "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
        # Liberation fonts (backup)
        "/usr/share/fonts/truetype/liberation/LiberationSans-Bold.ttf" if bold else "/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf",
        # Ubuntu fonts (another backup)
        "/usr/share/fonts/truetype/ubuntu/Ubuntu-Bold.ttf" if bold else "/usr/share/fonts/truetype/ubuntu/Ubuntu-Regular.ttf",
        # System fonts
        "/System/Library/Fonts/Helvetica.ttc",
        "/usr/share/fonts/TTF/arial.ttf"
    ]

    for font_path in font_paths:
        try:
            return ImageFont.truetype(font_path, size)
        except:
            continue

    # If all else fails, use default font but make it bigger
    print(f"Warning: Using default font for size {size}")
    return ImageFont.load_default()

# Font sizes - adjusted for better fit
header_font = get_font(28)  # For subreddit and timestamp
username_font = get_font(28)  # For username
title_font = get_font(42, bold=True)  # Smaller title font to prevent 3rd line
flair_font = get_font(24)  # For flair

# === Layout ===
left_margin = 20
current_y = 20

# 1. Subreddit and timestamp line
subreddit_line = f"{subreddit} • {timestamp}"
draw.text((left_margin, current_y), subreddit_line, fill=text_color, font=header_font)
current_y += 35

# 2. Username
draw.text((left_margin, current_y), username, fill=text_color, font=username_font)
current_y += 60  # More space before the big title

# 3. Post title - with text wrapping
# First, let's use the full title and wrap it
title_full = post_title

# Calculate how many characters fit per line with the large font
max_width = width - (left_margin * 2) - 50  # Leave some margin

# Function to wrap text properly
def wrap_text(text, font, max_width):
    lines = []
    words = text.split(' ')
    current_line = []

    for word in words:
        test_line = ' '.join(current_line + [word])
        bbox = draw.textbbox((0, 0), test_line, font=font)
        line_width = bbox[2] - bbox[0]

        if line_width <= max_width:
            current_line.append(word)
        else:
            if current_line:
                lines.append(' '.join(current_line))
                current_line = [word]
            else:
                # Word is too long, just add it anyway
                lines.append(word)
                current_line = []

    if current_line:
        lines.append(' '.join(current_line))

    return lines

# Wrap the title text
title_lines = wrap_text(title_full, title_font, max_width)

# Draw each line of the title
line_height = 60  # Space between lines
for i, line in enumerate(title_lines):
    draw.text((left_margin, current_y + (i * line_height)), line, fill=text_color, font=title_font)

# Move Y position down based on number of lines
current_y += len(title_lines) * line_height + 20

# 4. Flair at bottom left
flair_y = height - 80
flair_x = left_margin

# Calculate flair box dimensions
bbox = draw.textbbox((0, 0), flair_text, font=flair_font)
text_width = bbox[2] - bbox[0]
text_height = bbox[3] - bbox[1]

# Flair box padding
flair_padding_x = 15
flair_padding_y = 8

# Draw rounded rectangle for flair with white outline
flair_box = [
    flair_x,
    flair_y - flair_padding_y,
    flair_x + text_width + (flair_padding_x * 2),
    flair_y + text_height + flair_padding_y
]

# First draw a slightly larger white box for the outline
outline_width = 2  # thickness of outline
outline_box = [
    flair_box[0] - outline_width,
    flair_box[1] - outline_width,
    flair_box[2] + outline_width,
    flair_box[3] + outline_width
]

# Draw white outline
draw.rounded_rectangle(outline_box, radius=15 + outline_width, fill=(255, 255, 255))

# Draw blue flair box on top
draw.rounded_rectangle(flair_box, radius=15, fill=flair_bg_color)

# Draw flair text
draw.text((flair_x + flair_padding_x, flair_y), flair_text, fill=flair_text_color, font=flair_font)

# === Add white border around entire image ===
border_width = 3  # thickness of border
# Draw border on all four sides
# Top border
draw.rectangle([(0, 0), (width, border_width)], fill=(255, 255, 255))
# Bottom border
draw.rectangle([(0, height - border_width), (width, height)], fill=(255, 255, 255))
# Left border
draw.rectangle([(0, 0), (border_width, height)], fill=(255, 255, 255))
# Right border
draw.rectangle([(width - border_width, 0), (width, height)], fill=(255, 255, 255))

# === Save ===
# Save to Google Drive
img.save(f"{folder_path}/reddit_header.png")
print("✅ reddit_header.png saved to Google Drive")

# Display in Colab
try:
    from IPython.display import Image as IPImage, display
    display(IPImage("reddit_header.png"))
except:
    print("Note: Run in Colab to see image preview")

!ffmpeg -y -i "/content/drive/MyDrive/n8n/assets/subwaysurfers.mp4" -i "{folder_path}/reddit_header.png" \
-filter_complex "[1:v]scale=606:-1[overlay]; \
[0:v][overlay]overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2:enable='between(t,0,2)'" \
-t 2 -c:a copy "{folder_path}/headerpopup.mp4"

!ffmpeg -y -i "{folder_path}/headerpopup.mp4" \
-i "{assets_path}/soundEffect.mp3" \
-c:v copy -c:a aac -shortest "{folder_path}/headerpopup_with_sound.mp4"

!ffmpeg -y -i "{folder_path}/final.mp4" \
-c:v copy -c:a aac -ar 48000 -ac 1 \
"{folder_path}/final_normalized.mp4"

!ffmpeg -y -i "{folder_path}/headerpopup_with_sound.mp4" \
-c:v copy -c:a aac -ar 48000 -ac 1 \
"{folder_path}/header_normalized.mp4"

!echo "file '{folder_path}/header_normalized.mp4'" > /tmp/filelist.txt
!echo "file '{folder_path}/final_normalized.mp4'" >> /tmp/filelist.txt

!ffmpeg -y -f concat -safe 0 -i /tmp/filelist.txt -c copy "{folder_path}/concatenated_final.mp4"

import os
import pickle
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from google.auth.transport.requests import Request
from urllib.parse import urlparse, parse_qs

SCOPES = ['https://www.googleapis.com/auth/youtube.upload']

CLIENT_SECRET_PATH = '/content/drive/MyDrive/n8n/secrets/ClientSecret.json'
TOKEN_PATH = '/content/drive/MyDrive/n8n/secrets/channels/SubwaySurfersStory.pickle'

# Update video path to use our dynamic folder
VIDEO_PATH = f'{folder_path}/concatenated_final.mp4'

print(f"Video to upload: {VIDEO_PATH}")
print(f"Using channel token: SubwaySurfersStory")

def clear_existing_token():
    """Delete the existing token to force re-authentication"""
    if os.path.exists(TOKEN_PATH):
        os.remove(TOKEN_PATH)
        print("🗑️ Existing token deleted")
        return True
    else:
        print("ℹ️ No existing token found")
        return False

def authenticate_with_different_account():
    """Force authentication flow for a different account"""

    # Clear any existing token first
    clear_existing_token()

    print("🔐 Starting fresh authentication...")
    print("⚠️ IMPORTANT: Sign in with your YouTube account!")

    flow = InstalledAppFlow.from_client_secrets_file(CLIENT_SECRET_PATH, SCOPES)
    flow.redirect_uri = 'http://localhost'

    # Get the authorization URL
    auth_url, _ = flow.authorization_url(
        prompt='select_account',  # This forces account selection
        access_type='offline',
        include_granted_scopes='true'
    )

    print("\n📋 Follow these steps:")
    print("1. Copy this URL and open it in your browser:")
    print(f"   {auth_url}")
    print("\n2. ⚠️ Choose your YouTube account")
    print("3. Complete the authorization process")
    print("4. Copy the ENTIRE redirect URL from your browser")
    print("5. Paste it below")

    # Get the full redirect URL from user
    redirect_url = input("\n🔗 Paste the full redirect URL here: ").strip()

    # Extract the authorization code from the URL
    parsed_url = urlparse(redirect_url)
    auth_code = parse_qs(parsed_url.query).get('code')

    if auth_code:
        auth_code = auth_code[0]
        print(f"✅ Extracted authorization code: {auth_code[:10]}...")

        # Exchange the code for credentials
        flow.fetch_token(code=auth_code)
        creds = flow.credentials

        # Save the new credentials
        with open(TOKEN_PATH, 'wb') as token:
            pickle.dump(creds, token)
        print("💾 New credentials saved!")

        return creds
    else:
        print("❌ Could not find authorization code in URL")
        return None

print("✅ Authentication functions loaded")

from googleapiclient.http import MediaFileUpload

def load_credentials():
    """Load and refresh credentials if needed"""
    if not os.path.exists(TOKEN_PATH):
        print("❌ No authentication token found!")
        print("💡 Need to authenticate first")
        return None

    with open(TOKEN_PATH, 'rb') as token:
        creds = pickle.load(token)

    # Refresh token if expired
    if creds.expired and creds.refresh_token:
        print("🔄 Refreshing expired token...")
        creds.refresh(Request())

        # Save refreshed token
        with open(TOKEN_PATH, 'wb') as token:
            pickle.dump(creds, token)
        print("✅ Token refreshed and saved")

    return creds

def check_video_file():
    """Verify the video file exists and get info"""
    if not os.path.exists(VIDEO_PATH):
        print(f"❌ Video file not found: {VIDEO_PATH}")
        return False

    # Get file size
    file_size = os.path.getsize(VIDEO_PATH)
    file_size_mb = file_size / (1024 * 1024)

    print(f"📁 Video file found: {os.path.basename(VIDEO_PATH)}")
    print(f"📏 File size: {file_size_mb:.2f} MB")

    # Check if file is too large (128GB limit for YouTube)
    if file_size_mb > 128 * 1024:  # 128GB in MB
        print("⚠️ Warning: File is very large and may take a long time to upload")

    return True

print("✅ Upload functions loaded")

def upload_video():
    """Upload video to YouTube"""

    print("🚀 Starting YouTube Video Upload")
    print("=" * 50)

    # Step 1: Load credentials
    print("1️⃣ Loading credentials...")
    creds = load_credentials()
    if not creds:
        return False

    # Step 2: Check video file
    print("\n2️⃣ Checking video file...")
    if not check_video_file():
        return False

    # Step 3: Build YouTube service
    print("\n3️⃣ Building YouTube service...")
    try:
        youtube = build('youtube', 'v3', credentials=creds)
        print("✅ YouTube service created successfully")
    except Exception as e:
        print(f"❌ Failed to create YouTube service: {e}")
        return False

    # Step 4: Set up video metadata (we'll customize this next)
    print("\n4️⃣ Setting up video metadata...")

    video_metadata = {
        "snippet": {
            "title": lines[2].upper()[:100],
            "description": f"""
The best Reddit stories in the world

#subwaysurfers #gaming #story #shorts
            """.strip(),
            "tags": [
                "storytime",
                "redditstories",
                "shorts",
                "askreddit",
                "narration",

            ],
            "categoryId": "24",  # Shorts category
            "defaultLanguage": "en",
            "defaultAudioLanguage": "en"
        },
        "status": {
            "privacyStatus": "public",  # Start as private for safety
            "embeddable": True,
            "license": "youtube",
            "publicStatsViewable": True
        }
    }

    print("✅ Video metadata configured")
    print(f"   Title: {video_metadata['snippet']['title']}")
    print(f"   Privacy: {video_metadata['status']['privacyStatus']}")

    # Step 5: Create media upload object
    print("\n5️⃣ Preparing video upload...")
    try:
        media = MediaFileUpload(
            VIDEO_PATH,
            chunksize=-1,  # Upload in a single request
            resumable=True,  # Allows resuming if upload fails
            mimetype='video/mp4'
        )
        print("✅ Media upload object created")
    except Exception as e:
        print(f"❌ Failed to create media upload: {e}")
        return False

    # Step 6: Execute the upload
    print("\n6️⃣ Uploading video to YouTube...")
    print("⏳ This may take a while depending on file size and internet speed...")

    try:
        # Create the upload request
        request = youtube.videos().insert(
            part="snippet,status",
            body=video_metadata,
            media_body=media
        )

        # Execute the upload
        response = request.execute()

        # Success!
        video_id = response['id']
        video_url = f"https://www.youtube.com/watch?v={video_id}"

        print("\n🎉 SUCCESS! Video uploaded successfully!")
        print("=" * 50)
        print(f"📺 Video ID: {video_id}")
        print(f"🔗 Video URL: {video_url}")
        print(f"🔒 Privacy Status: {response.get('status', {}).get('privacyStatus', 'Unknown')}")

        return True

    except Exception as e:
        print(f"\n❌ Upload failed: {e}")
        return False

print("✅ Main upload function loaded")

def execute_upload_workflow():
    """Execute the complete upload workflow with error handling"""

    print("🎬 Starting automated YouTube upload workflow...")
    print("=" * 60)

    # First, check if we have valid credentials
    if os.path.exists(TOKEN_PATH):
        print("✅ Token file found, attempting upload...")
        success = upload_video()

        if success:
            print("\n🎉 Video uploaded successfully!")
            print("🔗 Check YouTube Studio for your new video")
            return True
        else:
            print("\n❌ Upload failed with existing token")
            print("💡 You may need to re-authenticate")
            return False
    else:
        print("❌ No authentication token found!")
        print("💡 You need to authenticate first")
        print("🔧 Run the authentication cell if you need to set up a new account")
        return False

# Execute the upload workflow automatically
print("🚀 Auto-executing YouTube upload...")
upload_success = execute_upload_workflow()

if upload_success:
    print(f"\n✅ Complete workflow finished successfully!")
    print(f"📁 Processed folder: {folder_name}")
    print(f"🎥 Final video: {VIDEO_PATH}")
    print(f"📺 Uploaded to YouTube: SubwaySurfersStory channel")
else:
    print(f"\n⚠️ Upload failed - but video processing completed")
    print(f"🎥 Video ready at: {VIDEO_PATH}")
    print(f"💡 You can manually upload or fix authentication")